function [emm] = emmeans(fitmodel, varargin)
% Estimate marginal means
% NOTE: this function only works with models that contain no categorical-continuous interactions.
% 
% Surprisingly, GeneralizedLinearMixedModel class does not store whether 
% the model was fit using OFFSET. so the user must indicate this.
% Same thing for the dummy variable encoding method.
% 
% Copyright 2019, J. Hartman, Cornell University
% % written using Matlab version R2016a 
% 
% INPUTS:
% fitmodel must be GeneralizedLinearMixedModel
% varargin can be several possibilities:
%  * spec: cell array of strings pertaining to variable names for which you
%          want marginal means estimated (DEFAULT is all combos)
%          E.g. emmeans(mdl,{'Smoker'})
% 
%  * wgtopts: string for a 'balanced' (DEFAULT) or 'unbalanced' design when
%          calculating weights for marginalizing variables.
%          E.g. emmeans(mdl,{'Smoker'},'unbalanced');
% 
%  * outtype: string indicating whether to output values in the same scale 
%          as the original 'response' variable or as the 'asfit' (DEFAULT) 
%          scale used to fit the model.
%          E.g. emmeans(mdl,'response');
% 
%  * offset: two sequential inputs. first, 'offset' (as string) and second,
%          the offset value as a double (DEFAULT = 0)
%          Note: offset is applied ~after~ scaling output via outtype
%          E.g. emmeans(mdl,'Offset',100)
% 
%  * alpha: a double (0,1) to calculate confidence intervals (DEFAULT=0.05)
%          E.g. emmeans(mdl,0.025);  
% 
%  * transformedvars: cell array of 
%          {1} a string of a variable name that was transformed prior to
%          model fitting (must be continuous variable),
%          {2} a function handle for the inverse of original transformation
%          {3} a function handle for original transformation
%          E.g. emmeans(mdl,{'Smoker',@(x) exp(x),@(x) log(x)});
% 
%  * dummytype: a string indicating either 'reference' (DEFAULT) or
%          'effects' coding. See MATLAB docs for
%          GeneralizedLinearMixedModel for more information on dummy
%          variable encoding methods.
%          E.g. emmeans(mdl,{'Smoker'},'effects');
% 
% OUTPUTS:  
% emm is a struct with fields:
%   table: table containing requested marginal mean estimates. 
%   DM: n x m logical array with n rows in emmtable and m coefficients in the
%       original model. DM is the design matrix for the rows in the emmtable.
% 
% example:
% emm = emmeans(mdl,'unbalanced');
% emm = emmeans(mdl,{'Smoker'},0.025,'effects');
% 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% Estimated marginal means are calculated by way of a design matrix that is
% determined by the requested marginal variables. The design matrix is
% generated by combining weights (for each model coefficient for each 
% marginalization step) with relevant coefficients based on groupings.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

% check/parse inputs
naccepted = 8; % just for varargin (spec, wgtopt, alpha, offset x2, output, transform, dummyvar)
narginchk(1,naccepted+1); 
[spec, m_var, wgtopts, alpha, offset, outtype, transformvars, dummytype] = parseInputs(fitmodel, varargin);

% continuous where formula included transformation of predictor var
% more info in get_transformed_weights
itran = ismember(fitmodel.VariableInfo.Properties.RowNames, transformvars{1})'; 

% get weights for each marginal variable 
% (wgts not matched to correct coefficients yet)
wgts = get_categorical_weights(fitmodel, spec, m_var, wgtopts);
wgts = get_continuous_weights(fitmodel, spec, m_var, wgts, itran);
wgts = get_transformed_weights(fitmodel, spec, m_var, wgts, itran, transformvars);

% make the design matrix with the weights
[emm.table,emm.DM] = get_designmatrix(fitmodel,spec,m_var,wgts,dummytype); 
% [fitmodel.CoefficientNames' num2cell(emm.DM(1,:)')] % to ensure wgts are correct
% calculate marginal (predicted) means
emm.table.Estimated_Marginal_Mean = emm.DM * fitmodel.Coefficients.Estimate;
emm.table.SE = sqrt( diag(emm.DM*fitmodel.CoefficientCovariance*emm.DM') );
% modify output from 'asfit' (coefficient) units 
if strcmp(outtype,'response') 
    emm.table.Estimated_Marginal_Mean = fitmodel.Link.Inverse(emm.table.Estimated_Marginal_Mean);
    emm.table.SE = fitmodel.Link.Inverse(emm.table.SE);
end
% modify output by offset
if offset~=0
    emm.table.Estimated_Marginal_Mean = emm.table.Estimated_Marginal_Mean + offset;
end
% add confidence intervals
ci = tinv( 1-alpha/2, fitmodel.DFE ) .* emm.table.SE;
ciStr = sprintf('CI_%2.1fpct',100*(1-alpha));
ciStr = strrep(ciStr,'.','_');
emm.table = [emm.table ...
    table( [emm.table.Estimated_Marginal_Mean-ci emm.table.Estimated_Marginal_Mean+ci],...
    'VariableNames',{ciStr}) ];
end

function [wgts, icat] = get_categorical_weights(mdl, specs, marvars, opts)
% initialize
wgts = ones(length(marvars),mdl.NumEstimatedCoefficients);
% get indices of categorical marginal variables
varnames = mdl.VariableInfo.Properties.RowNames;
icat = ismember(varnames,marvars)' & logical(mdl.VariableInfo.IsCategorical');
if ~any(icat)
    return % quit function early
end
% get indices of coefficients (easier to get NOT continuous vars)
catmars = varnames(icat)';
icontcoefs = ismember(mdl.CoefficientNames, marvars(~ismember(marvars,catmars))); % continuous vars exactly named (if no interaction terms)
% determine weights
ncoefs = sum(~icontcoefs);
if strcmp(opts,'balanced')
    % categorical var weights just 1/k
    k = cellfun('length', mdl.VariableInfo.Range(icat) ); 
    wgts(ismember(marvars, varnames(icat)),~icontcoefs) = repmat(1./k,1,ncoefs);
    
else % unbalanced
    % get the levels of the categorical marginal vars
    k = cellfun('length', mdl.VariableInfo.Range(icat) )'; 
    
    % loop through marvars individually for unbalanced weights
    tempmars = catmars;
    while ~isempty(tempmars)
        gtab = grpstats(mdl.Variables, [specs tempmars], {'sum'}, 'datavars', mdl.Formula.ResponseName);
        ngrp = gtab.GroupCount';
        % categorical var weights just (no. in group)/(total no.)
        tempwgts = bsxfun(@rdivide,reshape(ngrp,k(length(tempmars)),[]),sum(reshape(ngrp,k(length(tempmars)),[])));
        wgts(ismember(marvars, tempmars(end)),~icontcoefs) = repmat(tempwgts(:)',1,ncoefs/length(tempwgts(:)'));
        
        tempmars(end) = [];
    end
end
end
function [wgts] = get_continuous_weights(mdl, specs, marvars, wgts, itran)
% get indices of continuous marginal variables that weren't transformed
varnames = mdl.VariableInfo.Properties.RowNames;
icont = ~logical(mdl.VariableInfo.IsCategorical') & ~itran; %ismember(varnames,marvars)' & 
if ~any(icont)
    return % quit function early
end
% continuous var weights computed via grand means (replicates R results)
contvars = varnames(icont);
grandmean =  mean(mdl.Variables{:,contvars},'omitnan');
for ii=1:length(contvars)
    if ~ismember(contvars(ii),specs) % marginalized variable
        wgts(ismember(marvars, varnames(icont)),...
             ismember(mdl.CoefficientNames, contvars(ii))) = grandmean(ii);% continuous vars exactly named (if no interaction terms)
    else % specified variable
        wgts(:,...
             ismember(mdl.CoefficientNames, contvars(ii))) = grandmean(ii);
    end
end
% there may be a possibility that icontcoefs isn't ordered equivalently
% to mdl.Variables{:,contmars}. not quite sure
% % not sure if ever need a pooled grand mean
% % code here only for all combos of categorical interaction terms
% mtab = grpstats(mdl.Variables, [specs marvars(ismember(marvars, varnames(icat)))],...
%     {'mean'},'datavars',varnames(icont)); 
% pooledgrandmean = mean(mtab{:,end});
end
function [wgts] = get_transformed_weights(mdl, specs, marvars, wgts, itran, tvars)
% This is for continuous var that was transformed in formula.
% The issue is that for matlab you can't input say log(cell_area) in
% the formula so you need to transform the variable in the table before
% running the analysis. So, to find the grand mean, you must
% transform the variable, take the mean, and then back-transform it.
% Really the only way to address this is to know which variables to
% apply this to. I suppose you could do a more automatic work-around by
% renaming the variable (say log_cell_area) but this won't work for
% more complicated transformations. another option is a wrapper for
% fitglme that can accept formulas with transformations.
varnames = mdl.VariableInfo.Properties.RowNames;
if ~any(itran) 
    return % quit function early
end
ftrm = tvars{2} ; % inverse transform
fbtrm = tvars{3} ; % back transform 
% transform to orig var (exp), take mean, and back transform (log)
transvars = varnames(itran);
grandmean = ...
    varfun(fbtrm, ...
     varfun(@mean, ...
      varfun(ftrm, mdl.Variables(:,transvars)) ), 'OutputFormat', 'uniform' ) ;
for ii=1:length(transvars)
    if ~ismember(transvars(ii), specs) % marginalized variable
        wgts(ismember(marvars, transvars(ii)),...
             ismember(mdl.CoefficientNames, transvars(ii)) ) = grandmean(ii);% continuous vars exactly named (if no interaction terms)
    else % specified variable
        wgts(:,...
             ismember(mdl.CoefficientNames, transvars(ii)) ) = grandmean(ii);
    end
end
end
function [bal_table,DM] = get_designmatrix(mdl,spec,marvar,wgts,dum)
% organize predicted means the way user requested
icat = ismember(spec,mdl.VariableInfo.Properties.RowNames(logical(mdl.VariableInfo.IsCategorical)'));
if ~any(~icat)
    gm = wgts(ismember(mdl.CoefficientNames,spec(~icat))); % continuous vars exactly named (if no interaction terms)
else
    gm = wgts(1,ismember(mdl.CoefficientNames,spec(~icat))); % continuous vars exactly named (if no interaction terms)
end
% structure the output using native matlab function because very fast
pred_table = mdl.Variables(:,[spec marvar]);
pred_table.Estimate = predict(mdl, 'Conditional', false, 'Simultaneous', false); % default is in response units
pred_table(:,spec(~icat)) = num2cell(bsxfun(@times,ones(height(pred_table),1),gm));
bal_table = grpstats(pred_table, spec, {'mean'}, 'datavars', 'Estimate');
bal_table(:,~ismember(bal_table.Properties.VariableNames,spec)) = [];
% cycle through all the terms identifying conditions
allvars = [spec marvar];
allterms = regexp(mdl.CoefficientNames,':','split');
tlbl = cellfun('length', regexp(mdl.CoefficientNames,':')); % term labels based on number interactions
for ii=length(allvars):-1:1
    ispec(ii,:) = cellfun(@(y) ~isempty([y{:}]), cellfun(@(x) regexp(x,allvars{ii}), allterms, 'uni', 0));
end
% collect marginal var wgts
if isempty(marvar)
    DMwgts = ones(1,size(wgts,2));
else
    DMwgts = cumprod(sort(ispec(length(spec)+1:end,:) .* wgts,1,'descend'),1);
    DMwgts(DMwgts==0) = Inf;
    DMwgts = sort(DMwgts,1,'descend');
    DMwgts = DMwgts(end,:);
    DMwgts(isinf(DMwgts)) = 1;
    ispec(length(spec)+1:end,:)=[];
end
% determine reference levels
for jj=length(spec):-1:1
    snames = regexp([allterms{tlbl==0}],[spec{jj} '_'],'split');
    snames = [snames{cellfun('length',snames)==2}];
    snames = snames(~cellfun('isempty',snames));
    ref_lvl(jj) = setdiff(bal_table.(spec{jj}), snames);
end
% cycle through desired marginal means
for kk=height(bal_table):-1:1
    tempS = zeros(length(spec),length(allterms));
    for ll=length(spec):-1:1
        if ismember(bal_table{kk,spec{ll}},ref_lvl)
            % diff weights for 'reference' vs 'effects' dummy coding
            if strcmp(dum,'reference')
                dwgt = 0;
            else
                dwgt = -1;
            end
            tempS(ll,ispec(ll,:)) = dwgt * ones(1,sum(ispec(ll,:)));
        else
            tempS(ll,ispec(ll,:)) = cellfun(@(y) ~isempty([y{:}]), ...
                cellfun(@(x) regexp(x,bal_table{kk,spec{ll}}), allterms(ispec(ll,:)), 'uni', 0));
        end
    end
    DM(kk,:) = double(sum(abs(tempS),1)==sum(ispec,1)) - 2.*double(any(tempS==-1,1));
    DM(kk,abs(DM(kk,:))>1) = 0 ;
end
DM = bsxfun(@times,DM,DMwgts);
end
function [spec,m_var,wgtopts,alpha,offset,outtype,transformvars,dummytype] = parseInputs(mdl,fcninputs)
% allowing fcninputs to be unordered
% error check first
if ~isa(mdl, 'GeneralizedLinearMixedModel')
    error('Model input class must be GeneralizedLinearMixedModel');
end
% defaults
spec = mdl.Formula.FELinearFormula.PredictorNames; 
wgtopts = 'balanced';
alpha = 0.05;
offset = 0;
outtype = 'asfit';
transformvars = {''}; 
dummytype = 'reference';
% check for cell inputs
incel = fcninputs(cellfun('isclass',fcninputs,'cell'));
for ci=1:length(incel)
    if any(cellfun('isclass',incel{ci},'function_handle'))
        % unpack the transformations
        transformvars{1} = incel{ci}{1};
        transformvars{2} = incel{ci}{2}; % fcn_inverse
        transformvars{3} = incel{ci}{3}; % fcn_backtrans
        if ~any(strcmp(transformvars{1},mdl.Variables.Properties.VariableNames))
            error('Transform variable not found in model.');
        end
        if transformvars{2}(transformvars{3}(1))~=1
            error('Transforms are not proper inverses.');
        end
    elseif any(~ismember(incel{ci},spec))
        error('Error in cell input. Either check spelling for ''spec'' input, or check function call for ''transform'' input.');
    else
        % cell is for spec input
        spec = incel{ci};
    end
end
fcninputs(cellfun('isclass',fcninputs,'cell')) = [];
% check string inputs
instr = fcninputs(cellfun('isclass',fcninputs,'char'));
    function outchk = chkstr(ind,dflt) 
        if any(ind)
            outchk = instr{ind};
        else 
            outchk = dflt;
        end
    end
% offset
offmatch = 'off';
ioff = ~cellfun('isempty',regexpi(instr,offmatch,'once'));
if any(ioff)
    fidx = strcmp(fcninputs,instr(ioff));
    offset = fcninputs{find(fidx)+1};
    if ~isa(offset,'double')
        error('Value for ''offset'' must be class double.');
    end
    fcninputs(find(fidx)+1) = [];
end
% wgt opt
wgtmatch = 'bal';
iwgt = ~cellfun('isempty',regexpi(instr,wgtmatch,'once'));
wgtopts = chkstr(iwgt,wgtopts);
% output type (if input as string)
outmatch = {'response'}; % could add more
iout = ismember(instr,outmatch);
outtype = chkstr(iout,outtype);
% dummy variable encoding method
dummymatch = {'effects','sum'};
idum = ismember(instr,dummymatch);
dummytype = chkstr(idum,dummytype);
% remaining string is error
instr(any([ioff; iwgt; iout; idum])) = [];
if ~isempty(instr) && ~(any(strcmp(instr,'asfit')) || any(strcmp(instr,'balanced')) || any(strcmp(instr,'reference')))
    error('Too many inputs of class ''char''');
end
fcninputs(cellfun('isclass',fcninputs,'char')) = [];
% check double inputs (only alpha should remain)
innum = fcninputs(cellfun('isclass',fcninputs,'double'));
if length(innum)>1
    error('Too many inputs of class ''double''');
elseif length(innum)==1
    alpha = innum{1};
end
% get marginalized variable
used_names = mdl.VariableInfo.Properties.RowNames;
pred_names = mdl.Formula.FELinearFormula.PredictorNames;
if ~all(ismember(spec,pred_names))
    error('Marginal means must be modeled fixed effects.');
end
m_var = used_names( ismember(used_names, pred_names) & ~ismember(used_names,spec) )';
if ~isempty(m_var) && ~all(ismember(m_var,pred_names))
    error('Marginalized variables must be modeled fixed effects.');
end
end
